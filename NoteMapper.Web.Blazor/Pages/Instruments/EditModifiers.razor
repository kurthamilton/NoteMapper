@page "/instruments/{id:guid}/edit/modifiers"
@inherits NoteMapperComponentBase
@attribute [Authorize]

@using NoteMapper.Core
@using NoteMapper.Core.Extensions;
@using NoteMapper.Core.Guitars
@using NoteMapper.Data.Core.Instruments
@using NoteMapper.Services.Instruments
@using NoteMapper.Web.Blazor.Models.Instruments;
@using NoteMapper.Web.Blazor.Shared.Instruments
@using NoteMapper.Web.Blazor.Shared.Shared

<PageTitle>Edit instrument modifiers</PageTitle>

@if (UserInstrument == null)
{
    return;
}

<nav>
    <ol class="breadcrumb">
        <li class="breadcrumb-item">
            <a href="/instruments">Instruments</a>
        </li>
        <li class="breadcrumb-item active">
            @UserInstrument.Name
        </li>
        <li class="breadcrumb-item">
            <a href="/instruments/@Id/edit">Edit</a>
        </li>
        <li class="breadcrumb-item active">Modifiers</li>
    </ol>
</nav>

@if (Loading)
{
    <Loading />    
}
else
{
    <Feedback Model="Feedback" />

    <h1>@UserInstrument.Name</h1>
    <h3>Edit modifiers</h3>
    <p>
        Add, update, and delete pedals and levers below. 
    </p>
    <table class="table w-auto table-sm">
        <thead>
            <tr>
                <th>Type</th>
                <th>Name</th>
                <th>Incompatible with</th>
                <th></th>
            </tr>
        </thead>
        <tbody>
            @foreach (InstrumentModifierViewModel m in Model)
            {
                <tr>
                    <td>
                        @if (ModifierTypes.Count > 0)
                        {
                            <select class="form-control form-control-sm" @bind="@m.Type">
                                @foreach (string modifierType in ModifierTypes)
                                {
                                    <option>@modifierType</option>
                                }
                            </select>
                        }
                    </td>
                    <td>
                        <InputText @bind-Value="m.Name" class="form-control form-control-sm"
                            tabindex="@(Model.IndexOf(m) + 1)"/>
                    </td>
                    <td>
                        <div class="btn-group btn-group-sm">
                            @for (int i = 0; i < Model.Count; i++)
                            {
                                InstrumentModifierViewModel modifier = Model[i];
                                if (m.Type != modifier.Type)
                                {
                                    continue;
                                }

                                bool incompatible = m.IncompatibleModifiers.Contains(modifier);
                                string cssClass = modifier == m 
                                    ? "btn-outline-secondary" 
                                    : incompatible 
                                    ? "btn-danger" 
                                    : "btn-outline-danger";
                                
                                <button class="btn @(cssClass)"
                                        disabled="@(modifier == m)"
                                        @onclick="() => ToggleIncompatibleModifier(m, modifier)">
                                    @modifier.Name
                                </button>
                            }
                        </div>
                    </td>
                    <td>
                        <div class="btn-group btn-group-sm">
                            <button type="button" class="btn btn-outline-secondary"
                                    @onclick="(e => ReorderModifier(m, -1))">
                                <i class="bi bi-caret-up"></i>
                            </button>
                            <button type="button" class="btn btn-outline-secondary"
                                    @onclick="(e => ReorderModifier(m, 1))">
                                <i class="bi bi-caret-down"></i>
                            </button>
                        </div>
                        
                        <button type="button" class="btn btn-outline-danger btn-sm"
                                @onclick="(e => RemoveModifier(m))">
                            <i class="bi bi-x-circle"></i>
                        </button>
                    </td>
                </tr>
            }
        </tbody>
        <tfoot>
            <tr>    
                <td>
                </td>
                <td>
                    <button type="button" class="btn btn-outline-primary btn-sm w-100"
                        data-tooltip="Add modifier" @onclick="(e => AddModifier())">
                        <i class="bi bi-plus-circle"></i>
                    </button>
                </td>
                <td colspan="2">                    
                </td>
            </tr>
        </tfoot>
    </table>

    <button class="btn btn-primary" @onclick="HandleSubmitAsync">
        Update
    </button>
}

@inject IJSRuntime JsRuntime
@inject NavigationManager NavigationManager
@inject IUserInstrumentService UserInstrumentService
@code {
    [Parameter]
    public Guid Id { get; set; }

    Guid UserId { get; set; }
    UserInstrument? UserInstrument { get; set; }

    List<InstrumentModifierViewModel> Model { get; } = new();

    IReadOnlyCollection<string> ModifierTypes { get; set; } = Array.Empty<string>();

    protected override async Task OnInitializedAsync()
    {
        Guid? userId = await GetCurrentUserIdAsync();
        if (userId == null)
        {
            NavigationManager.NavigateTo("/");
            return;
        }

        UserId = userId.Value;
        UserInstrument = await UserInstrumentService.FindUserInstrumentAsync(UserId, Id.ToString());

        if (UserInstrument == null)
        {
            NavigationManager.NavigateTo("/instruments");
            return;
        }

        GuitarType type = Enum.Parse<GuitarType>(UserInstrument.Type, true);
        ModifierTypes = type.ModifierTypes().ToArray();

        LoadModel();

        Loading = false;
    }    

    private void AddModifier()
    {
        Model.Add(new InstrumentModifierViewModel
        {
            Type = ModifierTypes.First()
        });
    }

    private async Task HandleSubmitAsync()
    {
        if (Model == null || UserInstrument == null)
        {
            return;
        }

        List<UserInstrumentModifier> modifiers = new();
        for (int i = 0; i < Model.Count; i++)
        {
            InstrumentModifierViewModel viewModel = Model[i];

            UserInstrumentModifier modifier = new UserInstrumentModifier
            {
                Name = viewModel.Name,
                Type = viewModel.Type
            };

            if (viewModel.OriginalIndex != null)
            {
                UserInstrumentModifier original = UserInstrument.Modifiers[viewModel.OriginalIndex.Value];
                modifier.Offsets = original.Offsets;
            }

            if (viewModel.IncompatibleModifiers.Count > 0)
            {
                modifier.MutuallyExclusive = viewModel.IncompatibleModifiers
                    .Where(x => Model.IndexOf(x) > i)
                    .Select(x => x.Name)
                    .ToList();
            }

            modifiers.Add(modifier);
        }        

        UserInstrument.Modifiers.Clear();
        UserInstrument.Modifiers.AddRange(modifiers);

        ServiceResult result = await UserInstrumentService.UpdateInstrumentAsync(UserId, UserInstrument);
        SetFeedback(result);

        if (result.Success)
        {
            NavigationManager.NavigateTo($"/instruments/{UserInstrument.UserInstrumentId}/edit");
            return;
        }
    }

    private void LoadModel()
    {
        Model.Clear();

        if (UserInstrument == null)
        {
            return;
        }

        for (int modifierIndex = 0; modifierIndex < UserInstrument.Modifiers.Count; modifierIndex++)
        {
            UserInstrumentModifier modifier = UserInstrument.Modifiers.ElementAt(modifierIndex);
            InstrumentModifierViewModel modifierViewModel = new InstrumentModifierViewModel
            {
                Name = modifier.Name,
                OriginalIndex = modifierIndex,
                Type = modifier.Type
            };                        

            Model.Add(modifierViewModel);
        }

        for (int modifierIndex = 0; modifierIndex < UserInstrument.Modifiers.Count; modifierIndex++)
        {
            UserInstrumentModifier modifier = UserInstrument.Modifiers.ElementAt(modifierIndex);
            if (modifier.MutuallyExclusive != null)
            {
                foreach (string incompatibleModifier in modifier.MutuallyExclusive)
                {
                    UserInstrumentModifier? other = UserInstrument.Modifiers
                        .FirstOrDefault(x => string.Equals(x.Name, incompatibleModifier, StringComparison.InvariantCultureIgnoreCase));
                    if (other == null)
                    {
                        continue;
                    }

                    int otherIndex = UserInstrument.Modifiers.IndexOf(other);

                    Model[modifierIndex].IncompatibleModifiers.Add(Model[otherIndex]);
                    Model[otherIndex].IncompatibleModifiers.Add(Model[modifierIndex]);
                }
            }
        }
    }

    async Task RemoveModifier(InstrumentModifierViewModel modifier)
    {
        if (!await JsRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to delete this modifier?"))
        {
            return;
        }

        Model.Remove(modifier);

        foreach (InstrumentModifierViewModel m in Model)
        {
            if (m.IncompatibleModifiers.Contains(modifier))
            {
                m.IncompatibleModifiers.Remove(modifier);
            }
        }
    }

    void ReorderModifier(InstrumentModifierViewModel modifier, int direction)
    {
        Model.MoveOne(modifier, direction);
    }

    void ToggleIncompatibleModifier(InstrumentModifierViewModel modifier, InstrumentModifierViewModel other)
    {
        if (modifier.IncompatibleModifiers.Contains(other))
        {
            modifier.IncompatibleModifiers.Remove(other);
            other.IncompatibleModifiers.Remove(modifier);
        }
        else
        {
            modifier.IncompatibleModifiers.Add(other);
            other.IncompatibleModifiers.Add(modifier);
        }                
    }
}
