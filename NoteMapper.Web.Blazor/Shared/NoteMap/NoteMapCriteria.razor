@using NoteMapper.Core
@using NoteMapper.Core.Guitars;
@using NoteMapper.Core.MusicTheory
@using NoteMapper.Core.NoteMap;
@using NoteMapper.Services.Web.ViewModels.NoteMap
@using NoteMapper.Web.Blazor.Shared.Tour

@{
    if (Options == null)
    {
        return;
    }

    string formGroupClass = Inline ? "form-group" : "mb-3";
}

<div>
    @if (Inline)
    {
        <div class="float-end">
            <button class="btn btn-icon" data-nm-tour-for="@TourId" type="button">
                <i class="icon bi bi-question-circle"></i>
            </button>
        </div>
    }    

    <div class="@(Inline ? "form-inline d-block d-sm-flex align-items-center" : "")">        
        <div class="@formGroupClass" data-nm-tour-step="criteria-instrument">
            <label class="form-label" for="instrument">Instrument</label>
            <select class="form-control" id="instrument" value="@Model.InstrumentId" 
                    @onchange="OnInstrumentChange">
                @foreach (GuitarBase instrument in Options.DefaultInstruments)
                {
                    <option value="@instrument.Id">@instrument.Name</option>
                }

                @if (Options.UserInstruments.Count > 0)
                {
                    <option disabled>----------</option>

                    @foreach (GuitarBase instrument in Options.UserInstruments)
                    {
                        <option value="@instrument.Id">@instrument.Name</option>
                    }
                }
            </select>
        </div>

        <div class="@formGroupClass" data-nm-tour-step="criteria-key">
            <label class="form-label" for="key">Key</label>
            <div class="d-flex">
                <select class="form-control" id="key" value="@Model.NoteIndex" @onchange="OnKeyNameChange">
                    @foreach (int noteIndex in Options.NoteIndexes)
                    {
                        <option value="@noteIndex">@(Note.GetName(noteIndex, Model.Accidental))</option>
                    }
                </select>
                <select class="form-control" id="key" value="@Model.ScaleType" @onchange="OnScaleTypeChange">
                    @foreach (string type in Options.ScaleTypes)
                    {
                        <option>@type</option>
                    }
                </select>
            </div>
        </div>

        <div class="@formGroupClass">
            <label class="form-label" for="type">Type</label>
            <select class="form-control" id="type" value="@Model.Type.ToString()" @onchange="OnTypeChange">
                @foreach (NoteMapType type in Options.Types)
                {
                    <option>@type.ToString()</option>
                }
            </select>
        </div>

        <div class="@formGroupClass" data-nm-tour-step="criteria-mode">
            <label class="form-label" for="mode">Mode</label>
            <select class="form-control" id="mode" value="@Model.Mode.ToString()" @onchange="OnModeChange">
                @foreach (NoteMapMode mode in Options.Modes)
                {
                    <option>@mode.ToString()</option>
                }
            </select>
        </div>

        <div class="@formGroupClass"data-nm-tour-step="criteria-intervals">
            @if (Inline)
            {
                <label>&nbsp;</label>
            }        

            <div class="form-check">
                <input type="checkbox" class="form-check-input" id="show-intervals"
                       checked="@Model.ShowIntervals" @onchange="OnShowIntervalsChange">
                <label class="form-check-label" for="show-intervals">Intervals</label>
            </div>
        </div>

        <div class="@formGroupClass" data-nm-tour-step="criteria-accidental">
            @foreach (string option in Options.Accidentals)
            {
                AccidentalType type = Accidental.Parse(option);
                <div class="form-check @(Inline ? null : "form-check-inline")">
                    <input class="form-check-input" type="radio" name="accidental-@(Inline ? "inline" : "block")" id="accidental-@type"
                       checked="@(Model.Accidental == type)" @onchange="OnAccidentalChange"
                       value="@option">
                    <label class="form-check-label" for="accidental-@type">
                        @option
                    </label>
                </div>
            }        
        </div>
    </div>
</div>

<TourContainer TourId="@TourId" Title="Options">    
    <TourStep Target="criteria-instrument">
        <p>Choose your instrument</p>
        <p>Instruments can be viewed and created from the <a href="/instruments" target="_blank">instruments</a> page</p>
    </TourStep>    
    <TourStep Target="criteria-key">
        <p>Select your key</p>
    </TourStep>
    <TourStep Target="criteria-mode">
        <p>Choose between having all possible modifier combinations displayed or selecting custom modifiers</p>
    </TourStep>
    <TourStep Target="criteria-intervals">
        <p>Note names (C, D, F# etc) are displayed by default. Choose whether you would prefer to see the note intervals</p>
    </TourStep>
    <TourStep Target="criteria-accidental">
        <p>Choose whether notes should be displayed as sharps or flats</p>
    </TourStep>
</TourContainer>

@code {
    [Parameter]
    public bool Inline { get; set; }

    [Parameter]
    public NoteMapCriteriaOptionsViewModel? Options { get; set; }

    [Parameter]
    public EventCallback<NoteMapCriteriaViewModel> OnChange { get; set; }

    [Parameter]
    public NoteMapCriteriaViewModel Model { get; set; } = new();

    string TourId => $"criteria{(Inline ? "-inline" : "")}";

    protected override void OnInitialized()
    {
        base.OnInitialized();
    }

    Task OnAccidentalChange(ChangeEventArgs e)
    {
        string? value = (string?)e.Value;
        if (value == null)
        {
            return Task.CompletedTask;
        }
        
        Model.Accidental = Accidental.Parse(value);
        return EmitChange();
    }

    Task OnInstrumentChange(ChangeEventArgs e)
    {
        Model.InstrumentId = (string?)e.Value;
        return EmitChange();
    }

    Task OnKeyNameChange(ChangeEventArgs e)
    {
        Model.NoteIndex = int.Parse((string?)e.Value ?? "0");
        return EmitChange();
    }

    Task OnModeChange(ChangeEventArgs e)
    {
        string value = (string?)e.Value ?? "";
        NoteMapMode mode = Enum.Parse<NoteMapMode>(value, true);
        Model.Mode = Enum.IsDefined<NoteMapMode>(mode) ? mode : default;
        return EmitChange();
    }

    Task OnScaleTypeChange(ChangeEventArgs e)
    {
        Model.ScaleType = (string?)e.Value;
        return EmitChange();
    }

    Task OnShowIntervalsChange(ChangeEventArgs e)
    {
        Model.ShowIntervals = (bool?)e.Value ?? false;
        return EmitChange();
    }

    Task OnTypeChange(ChangeEventArgs e)
    {
        string value = (string?)e.Value ?? "";
        NoteMapType type = Enum.Parse<NoteMapType>(value, true);
        Model.Type = Enum.IsDefined<NoteMapType>(type) ? type : default;
        return EmitChange();
    }

    Task EmitChange()
    {
        return OnChange.InvokeAsync(Model);
    }
}
